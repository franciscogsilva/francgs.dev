---
import type { HeadingItem } from "../helpers/tableOfContents";

export interface Props {
  headings: HeadingItem[];
  articleId?: string;
}

const { headings, articleId } = Astro.props;
---

{
  headings.length > 0 && (
    <nav class="toc" aria-label="Table of contents">
      <h2 class="toc-title">On this page</h2>
      <ul class="toc-list">
        {headings.map((heading) => (
          <li class={`toc-item toc-depth-${heading.depth}`}>
            <a
              href={`#${heading.slug}`}
              class="toc-link"
              data-target={heading.slug}
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ul>

      {articleId && (
        <div class="toc-reactions" data-article-id={articleId}>
          <button
            class="reaction-btn"
            data-reaction="love"
            aria-label="Love"
            title="Love this article"
          >
            <span class="emoji">‚ù§Ô∏è</span>
            <span class="count" />
          </button>
          <button
            class="reaction-btn"
            data-reaction="clap"
            aria-label="Clap"
            title="Great content"
          >
            <span class="emoji">üëè</span>
            <span class="count" />
          </button>
          <button
            class="reaction-btn"
            data-reaction="target"
            aria-label="On target"
            title="Right on target"
          >
            <span class="emoji">üéØ</span>
            <span class="count" />
          </button>
          <button
            class="reaction-btn"
            data-reaction="idea"
            aria-label="Great idea"
            title="Brilliant idea"
          >
            <span class="emoji">üí°</span>
            <span class="count" />
          </button>
        </div>
      )}
    </nav>
  )
}

<style>
  .toc {
    position: sticky;
    top: 2rem;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    padding-left: 1rem;
  }

  .toc-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin-top: 0;
    margin-bottom: 1rem;
    color: rgb(156 163 175);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
    border-left: 1px solid rgba(75, 85, 99, 0.3);
  }

  .toc-item {
    margin: 0;
    padding: 0;
  }

  .toc-depth-2 {
    padding-left: 0;
  }

  .toc-depth-3 {
    padding-left: 1rem;
  }

  .toc-link {
    color: rgb(156 163 175);
    text-decoration: none;
    transition: all 0.2s ease;
    display: block;
    padding: 0.375rem 0 0.375rem 1rem;
    font-size: 0.875rem;
    line-height: 1.4;
    border-left: 2px solid transparent;
    margin-left: -1px;
    position: relative;
  }

  .toc-link:hover {
    color: rgb(209 213 219);
  }

  .toc-link.active {
    color: var(--primary-color);
    border-left-color: var(--primary-color);
    font-weight: 500;
  }

  /* Hide scrollbar but keep functionality */
  .toc::-webkit-scrollbar {
    width: 4px;
  }

  .toc::-webkit-scrollbar-track {
    background: transparent;
  }

  .toc::-webkit-scrollbar-thumb {
    background: rgba(75, 85, 99, 0.3);
    border-radius: 2px;
  }

  .toc::-webkit-scrollbar-thumb:hover {
    background: rgba(75, 85, 99, 0.5);
  }

  /* Reactions */
  .toc-reactions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid rgba(75, 85, 99, 0.2);
    justify-content: center;
  }

  .reaction-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 0.25rem;
    transition: all 0.2s ease;
    opacity: 0.4;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .reaction-btn:hover {
    opacity: 1;
  }

  .reaction-btn.active {
    opacity: 1;
  }

  .emoji {
    font-size: 1.5rem;
    line-height: 1;
    display: block;
  }

  .count {
    font-size: 0.75rem;
    font-weight: 600;
    color: inherit;
  }

  .reaction-btn.has-reactions {
    opacity: 0.7;
  }

  .reaction-btn.has-reactions:hover {
    opacity: 1;
  }
</style>

<script>
  // Active section tracking on scroll
  function setupTocActiveTracking() {
    const tocLinks = document.querySelectorAll(".toc-link");
    const headings = Array.from(document.querySelectorAll("h2[id], h3[id]"));

    if (tocLinks.length === 0 || headings.length === 0) {
      console.log("TOC: No links or headings found");
      return;
    }

    console.log(
      `TOC: Found ${tocLinks.length} links and ${headings.length} headings`,
    );

    function updateActiveLink() {
      // Get current scroll position
      const scrollY = window.scrollY;
      const offset = 100; // Offset from top to consider a section "active"

      // Find which heading is currently in view
      let currentHeading = null;

      for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i];
        const headingTop = heading.getBoundingClientRect().top + scrollY;

        if (scrollY >= headingTop - offset) {
          currentHeading = heading;
          break;
        }
      }

      // If no heading is in view yet, use the first one
      if (!currentHeading && headings.length > 0) {
        currentHeading = headings[0];
      }

      // Update active states
      tocLinks.forEach((link) => link.classList.remove("active"));

      if (currentHeading) {
        const id = currentHeading.getAttribute("id");
        const activeLink = document.querySelector(
          `.toc-link[data-target="${id}"]`,
        );

        if (activeLink) {
          activeLink.classList.add("active");
          console.log(`TOC: Active section - ${id}`);
        }
      }
    }

    // Handle TOC link clicks with smooth scroll and proper offset
    tocLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        const targetId = link.getAttribute("data-target");

        if (!targetId) return;

        const targetElement = document.getElementById(targetId);

        if (targetElement) {
          // Calculate position with offset for sticky header
          const headerOffset = 150; // Increased offset for better positioning
          const elementPosition = targetElement.getBoundingClientRect().top;
          const offsetPosition =
            elementPosition + window.scrollY - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: "smooth",
          });

          // Update active state after scroll
          setTimeout(() => {
            tocLinks.forEach((l) => l.classList.remove("active"));
            link.classList.add("active");
          }, 100);
        }
      });
    });

    // Update on scroll with throttle
    let ticking = false;
    window.addEventListener(
      "scroll",
      () => {
        if (!ticking) {
          window.requestAnimationFrame(() => {
            updateActiveLink();
            ticking = false;
          });
          ticking = true;
        }
      },
      { passive: true },
    );

    // Update on load
    updateActiveLink();
  }

  // Run on page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupTocActiveTracking);
  } else {
    setupTocActiveTracking();
  }

  // Re-run after view transitions (for Astro)
  document.addEventListener("astro:after-swap", setupTocActiveTracking);

  // Reactions handling with Supabase
  function initReactions() {
    const container = document.querySelector(".toc-reactions");
    if (!container) return;

    const articleIdAttr = container.getAttribute("data-article-id");
    if (!articleIdAttr) return;

    // Type refinement: articleId is now guaranteed to be string
    const articleId: string = articleIdAttr;

    const buttons = container.querySelectorAll(".reaction-btn");

    // Load reactions from Supabase
    async function loadReactions() {
      try {
        const response = await fetch(
          `/api/reactions?articleId=${encodeURIComponent(articleId)}`,
        );
        const data = await response.json();

        buttons.forEach((btn) => {
          const reaction = btn.getAttribute("data-reaction");
          if (!reaction) return;

          const count = data[reaction] || 0;
          const countSpan = btn.querySelector(".count");

          // Update button appearance based on count
          if (count > 0) {
            btn.classList.add("has-reactions");
            btn.setAttribute("title", `${count} reactions`);
            if (countSpan) countSpan.textContent = count.toString();
          } else {
            if (countSpan) countSpan.textContent = "";
          }

          // Check if user has reacted (from localStorage for UX)
          const userReactionsKey = `user_reactions_${articleId}`;
          const userReactions = JSON.parse(
            localStorage.getItem(userReactionsKey) || "[]",
          );
          if (userReactions.includes(reaction)) {
            btn.classList.add("active");
          }
        });
      } catch (error) {
        console.error("Error loading reactions:", error);
      }
    }

    // Add reaction
    async function addReaction(reaction: string) {
      try {
        const response = await fetch("/api/reactions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ articleId, reactionType: reaction }),
        });

        const data = await response.json();

        if (!response.ok) {
          alert(data.error || "Failed to add reaction");
          return;
        }

        // Update localStorage for UX
        const userReactionsKey = `user_reactions_${articleId}`;
        const userReactions = JSON.parse(
          localStorage.getItem(userReactionsKey) || "[]",
        );

        if (!userReactions.includes(reaction)) {
          userReactions.push(reaction);
          localStorage.setItem(userReactionsKey, JSON.stringify(userReactions));
        }

        // Reload to show updated counts
        await loadReactions();
      } catch (error) {
        console.error("Error adding reaction:", error);
        alert("Failed to add reaction. Please try again.");
      }
    }

    // Add click handlers
    buttons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const reaction = btn.getAttribute("data-reaction");
        if (reaction) {
          addReaction(reaction);
        }
      });
    });

    loadReactions();
  }

  // Initialize reactions
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initReactions);
  } else {
    initReactions();
  }

  document.addEventListener("astro:page-load", initReactions);
</script>
